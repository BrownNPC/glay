// Code generated by wazero-emscripten-embind, DO NOT EDIT.
package internal

import (
	"context"

	"github.com/jerbob92/wazero-emscripten-embind"
)

type ClassClay struct {
	embind.ClassBase
}

func (class *ClassClay) Clone(ctx context.Context) (*ClassClay, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassClay), nil
}

func (class *ClassClay) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassClay) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassClay) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassClay) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassClay) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassClay) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassClay) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassClay) BeginLayout(ctx context.Context) error {
	_, err := class.CallMethod(ctx, "BeginLayout")
	return err
}

func (class *ClassClay) EndLayout(ctx context.Context) (embind.ClassBase, error) {
	res, err := class.CallMethod(ctx, "EndLayout")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func NewClassClay(e embind.Engine, ctx context.Context, arg0 uint32, arg1 uint32) (*ClassClay, error) {
	res, err := e.CallPublicSymbol(ctx, "Clay", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassClay), nil
}

type ClassDimensions struct {
	embind.ClassBase
}

func (class *ClassDimensions) Clone(ctx context.Context) (*ClassDimensions, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassDimensions), nil
}

func (class *ClassDimensions) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassDimensions) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassDimensions) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassDimensions) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassDimensions) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassDimensions) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassDimensions) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassDimensions) GetPropertyHeight(ctx context.Context) (float32, error) {
	res, err := class.GetProperty(ctx, "height")
	if err != nil {
		return float32(0), err
	}

	if res == nil {
		return float32(0), nil
	}

	return res.(float32), nil
}
func (class *ClassDimensions) SetPropertyHeight(ctx context.Context, val float32) error {
	return class.SetProperty(ctx, "height", val)
}

func (class *ClassDimensions) GetPropertyWidth(ctx context.Context) (float32, error) {
	res, err := class.GetProperty(ctx, "width")
	if err != nil {
		return float32(0), err
	}

	if res == nil {
		return float32(0), nil
	}

	return res.(float32), nil
}
func (class *ClassDimensions) SetPropertyWidth(ctx context.Context, val float32) error {
	return class.SetProperty(ctx, "width", val)
}

func NewClassDimensions(e embind.Engine, ctx context.Context) (*ClassDimensions, error) {
	res, err := e.CallPublicSymbol(ctx, "Dimensions")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassDimensions), nil
}

type ClassRenderCommandArray struct {
	embind.ClassBase
}

func (class *ClassRenderCommandArray) Clone(ctx context.Context) (*ClassRenderCommandArray, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassRenderCommandArray), nil
}

func (class *ClassRenderCommandArray) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassRenderCommandArray) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassRenderCommandArray) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassRenderCommandArray) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassRenderCommandArray) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassRenderCommandArray) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassRenderCommandArray) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassRenderCommandArray) GetPropertyLength(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "length")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassRenderCommandArray) SetPropertyLength(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "length", val)
}

func (class *ClassRenderCommandArray) Get(ctx context.Context, arg0 any) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

type ClassStringSlice struct {
	embind.ClassBase
}

func (class *ClassStringSlice) Clone(ctx context.Context) (*ClassStringSlice, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassStringSlice), nil
}

func (class *ClassStringSlice) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassStringSlice) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassStringSlice) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassStringSlice) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassStringSlice) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassStringSlice) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassStringSlice) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassStringSlice) GetPropertyLength(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "length")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassStringSlice) SetPropertyLength(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "length", val)
}

type ClassTextElementConfig struct {
	embind.ClassBase
}

func (class *ClassTextElementConfig) Clone(ctx context.Context) (*ClassTextElementConfig, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassTextElementConfig), nil
}

func (class *ClassTextElementConfig) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassTextElementConfig) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassTextElementConfig) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassTextElementConfig) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassTextElementConfig) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassTextElementConfig) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassTextElementConfig) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}
